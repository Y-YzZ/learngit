Apache Kafka 是一款开源的分布式的消息引擎系统。

## 消息引擎系统

### 一、定义

- 根据维基百科的定义，消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。
- 系统 A 发送消息给消息引擎系统，系统 B 从消息引擎系统中读取 A 发送的消息。

### 二、消息编码格式

纯二进制的字节序列。消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列。

### 三、传输协议

Kafka同时支持以下两种消息引擎模型

- __点对点模型（Peer to Peer）：__ 也叫消息队列模型，A的消息只能由B接收，类似电话的1V1
- __发布/订阅模型：__ 存在主题（topic），发布者（Publisher），订阅者（Subscriber）的概念，和mqtt类似，客户端作为发布者发布某个主题消息，也可以作为订阅者订阅相应主题的消息。类似与某个话题（=topic）中用户可以提出（=publish）自己的各种想法，其他用户可以通过关注（=subscribe）该话题来看其他人的想法，同时自己也可以发表(=publish)意见

#### 削峰填谷

- 对抗上下游系统TPS的错配以及瞬时峰值流量，避免流量震荡。如，秒杀业务中，Kafka将瞬时增加的订单流量保存在对应的主题中，不影响上游服务的TPS，也给下游服务留出了充足的时间去消费。[TPS/QPS/系统吞吐量](https://blog.csdn.net/u010889616/article/details/83245695)
- 发送方和接收方松耦合，简化了应用的开发，减少了系统间不必要的交互。

## Kafka术语

- 消息（Record）：Kafka 处理的主要对象
- 主题（Topic）：发布和订阅的对象，承载此宋词发逻辑容器，在实际使用中用来区分具体业务
- 分区（Partition）：一个有序不变的消息序列。每个主题下可以有多个分区
- 消息位移（Offset）：表示分区中每条消息的位置信息，是一个单调递增且不变的值。
- 副本（Replica）：Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。
- 生产者（Producer）：向主题发布新消息的应用程序
- 消费者（Consumer）：从主题订阅新消息的应用程序
- 消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移。
- 消费者组（Consumer Group）：多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。
- 重平衡（Rebalance）：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。
- 客户端（Clients）：生产者和消费者统称客户端
- Kafka集群：由多个Broker的服务进程构成
- Broker：负责接收和处理客户端发来的请求，以及对消息进行持久化
![kafka概念的图表](resourse/kafka概念.png)

### 一、高可用

1. 将Broker分散运行在不同机器上，保证一台机器宕机后，其他机器的Broker也依然能够对外提供服务。（虽然多个Broker进程也可以运行在同一机器上）
2. 备份机制（Replication）：把相同的数据拷贝到多台机器上，相同的数据拷贝叫做副本（Replica），保证数据的持久化或消息不丢失
   - 领导者副本（Leader Replica）: 对外提供服务，与客户端程序进行交互
   - 追随者副本（Follower Replica）：被动的追随领导者副本，kafka中的追随者副本不能与外界进行交互（MySQL的从库可以处理读操作）
   - 副本的工作机制

    ```mermaid
    sequenceDiagram
    追随者副本->>领导者副本: 发送请求
    领导者副本->>追随者副本: 发送最新生产的消息
    消费者->>领导者副本: 读消息
    生产者 ->> 领导者副本: 写消息
    ```

### 二、伸缩性（Scalability）

- 分区机制：将每个主题划分成功多个分区（Partition），每个分区是一组有序的消息日志。生产者发送的消息只会被发送到一个分区中。
  - 分区（Partitioning）：一个有序不变的消息序列。Kafka（原理同MongoDB和Elasticsearch中Sharding、HBase中的Region）

__副本&分区：__

- 副本是在分区级别定义的。
- 每个分区下可以配置若干个副本，其中只能有 1 个领导者副本和 N-1 个追随者副本。
  - 生产者向分区写入消息，每条消息在分区中的位置信息由位移（Offset）的数据来表征。（一个空分区中写10条消息，消息的位移依次为0，1，2…， 9）

__Kafka三层消息架构:__

- __主题层：__ 每个主题可以配置M个分区，每个分区可以配置N个副本。
- __分区层：__ 每个分区的N个副本中只有一个领导者副本，对外提供服务；其他N-1个追随者副本，提供数据冗余。
- __消息层:__ 分区中若按消息，每条消息的位移从0开始，一次递增。

### 三、持久化数据

- 消息日志（Log）：保存数据，一个日志为磁盘上只能追加写（Append-only）消息的物理文件。（只能追加写，避免了随机I/O操作，改为性能较好的I/O写操作，实现Kafka高吞吐量的手段之一）
- 日志段（Log Segment）机制：一个日志细分成多个日志段，消息被追加到最新的日志段，一个日志段满后，自动切分新的日志段，将老的日志段封存起来，Kafka在后台定期检查老的日志段是否能删除，从而回收磁盘空间。

__消费者:__

- 消费者组（Consumer Group）：多个消费者实例组成一个组来消费一组主题。一组主题中的每个分区只能由组内的一个消费者实例消费，其他消费者实例不能消费（P2P模型）（多个消费实例同时小给，提高整个消费端的吞吐量TPS）
- 消费者实例（Consumer Instance）：可以运行消费者应用的进程/线程
- 重平衡（Rebalance）：消费者组中的消费者实例彼此协作。组内某个实例挂了之后，Kafka将该实例负责的分区转移给其他活着的分区（很厉害，但也存在很多还未解决的bug）
- 消费者位移（Consumer Offset）：记录消费者消费到了分区的哪个位置，是消费者消费进度的指示器。
